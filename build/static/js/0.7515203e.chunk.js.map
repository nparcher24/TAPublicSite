{"version":3,"sources":["../node_modules/react-reveal/Fade.js","../../../src/hooks/use-iso-morphic-effect.ts","../../../src/utils/render.ts","../../../src/utils/match.ts","../../../src/hooks/use-server-handoff-complete.ts","../../../src/hooks/use-id.ts","../../../src/hooks/use-is-mounted.ts","../../../src/internal/open-closed.tsx","../../../../../src/components/transitions/utils/transition.ts","../../../src/utils/disposables.ts","../../../src/utils/once.ts","../../../../src/components/transitions/transition.tsx","../../../src/hooks/use-is-initial-render.ts"],"names":["_objectWithoutProperties","o","e","r","t","indexOf","Object","prototype","hasOwnProperty","call","make","distance","left","p","right","a","up","l","down","i","top","u","bottom","n","big","s","mirror","d","opposite","_","toString","lookup","f","y","b","v","c","_globals","animation","Fade","arguments","length","defaults","children","out","forever","timeout","duration","delay","count","style","animationFillMode","reverse","_wrap2","default","defineProperty","exports","value","_propTypes","require","_wrap","__esModule","propTypes","bool","number","string","module","useIsoMorphicEffect","window","useEffect","Features","RenderStrategy","render","props","slot","defaultTag","features","visible","name","_render","featureFlags","isStatic","rest","unmount","strategy","match","hidden","display","omit","as","Component","tag","refName","passThroughProps","refRelatedProps","resolvedChildren","isValidElement","Array","Error","line","cloneElement","clone","func","existingProps","event","mergeEventFunctions","compact","createElement","forwardRefWithAs","component","forwardRef","displayName","keysToOmit","key","returnValue","args","error","state","serverHandoffComplete","useServerHandoffComplete","useState","setServerHandoffComplete","id","generateId","useId","ready","setId","useIsMounted","mounted","useRef","State","Context","createContext","useOpenClosed","useContext","OpenClosedProvider","Reason","disposables","api","requestAnimationFrame","raf","cancelAnimationFrame","nextFrame","setTimeout","timer","clearTimeout","add","dispose","addClasses","node","classes","removeClasses","transition","base","from","to","entered","done","_done","cb","called","once","getComputedStyle","transitionDuration","transitionDelay","map","parseFloat","z","resolvedValue","durationMs","delaysMs","waitForTransition","reason","useSplitClasses","useMemo","className","TransitionContext","TreeStates","NestingContext","hasChildren","bag","useNesting","doneRef","transitionableChildren","unregister","useCallback","Hidden","idx","register","child","Visible","childId","noop","eventNames","ensureEventHooksExist","events","result","TransitionChildRenderFeatures","TransitionChild","beforeEnter","afterEnter","beforeLeave","afterLeave","enter","enterFrom","enterTo","leave","leaveFrom","leaveTo","container","setState","context","useTransitionContext","show","appear","initial","useParentNesting","isTransitioning","nesting","enterClasses","enterFromClasses","enterToClasses","enteredClasses","leaveClasses","leaveFromClasses","leaveToClasses","eventsRef","useEvents","skip","propsWeControl","ref","passthroughProps","Transition","usesOpenClosedState","includes","nestingBag","useIsInitialRender","transitionBag","sharedProps","React","hasTransitionContext","hasOpenClosedContext"],"mappings":"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","file":"static/js/0.7515203e.chunk.js","sourcesContent":["\"use strict\";function _interopRequireDefault(o){return o&&o.__esModule?o:{default:o}}function _objectWithoutProperties(o,e){var r={};for(var t in o)e.indexOf(t)>=0||Object.prototype.hasOwnProperty.call(o,t)&&(r[t]=o[t]);return r}function make(o,e){var r=e.distance,t=e.left,p=e.right,a=e.up,l=e.down,i=e.top,u=e.bottom,n=e.big,s=e.mirror,d=e.opposite,_=(r?r.toString():0)+((t?1:0)|(p?2:0)|(i||l?4:0)|(u||a?8:0)|(s?16:0)|(d?32:0)|(o?64:0)|(n?128:0));if(lookup.hasOwnProperty(_))return lookup[_];var f=t||p||a||l||i||u,y=void 0,b=void 0;if(f){if(!s!=!(o&&d)){var v=[p,t,u,i,l,a];t=v[0],p=v[1],i=v[2],u=v[3],a=v[4],l=v[5]}var c=r||(n?\"2000px\":\"100%\");y=t?\"-\"+c:p?c:\"0\",b=l||i?\"-\"+c:a||u?c:\"0\"}return lookup[_]=(0,_globals.animation)((o?\"to\":\"from\")+\" {opacity: 0;\"+(f?\" transform: translate3d(\"+y+\", \"+b+\", 0);\":\"\")+\"}\\n     \"+(o?\"from\":\"to\")+\" {opacity: 1;transform: none;} \"),lookup[_]}function Fade(){var o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:_globals.defaults,e=arguments.length>1&&void 0!==arguments[1]&&arguments[1],r=o.children,t=(o.out,o.forever),p=o.timeout,a=o.duration,l=void 0===a?_globals.defaults.duration:a,i=o.delay,u=void 0===i?_globals.defaults.delay:i,n=o.count,s=void 0===n?_globals.defaults.count:n,d=_objectWithoutProperties(o,[\"children\",\"out\",\"forever\",\"timeout\",\"duration\",\"delay\",\"count\"]),_={make:make,duration:void 0===p?l:p,delay:u,forever:t,count:s,style:{animationFillMode:\"both\"},reverse:d.left};return e?(0,_wrap2.default)(d,_,_,r):_}Object.defineProperty(exports,\"__esModule\",{value:!0});var _propTypes=require(\"prop-types\"),_globals=require(\"./globals\"),_wrap=require(\"./wrap\"),_wrap2=_interopRequireDefault(_wrap),propTypes={out:_propTypes.bool,left:_propTypes.bool,right:_propTypes.bool,top:_propTypes.bool,bottom:_propTypes.bool,big:_propTypes.bool,mirror:_propTypes.bool,opposite:_propTypes.bool,duration:_propTypes.number,timeout:_propTypes.number,distance:_propTypes.string,delay:_propTypes.number,count:_propTypes.number,forever:_propTypes.bool},lookup={};Fade.propTypes=propTypes,exports.default=Fade,module.exports=exports.default;","import { useLayoutEffect, useEffect } from 'react'\n\nexport const useIsoMorphicEffect = typeof window !== 'undefined' ? useLayoutEffect : useEffect\n","import {\n  Fragment,\n  cloneElement,\n  createElement,\n  forwardRef,\n  isValidElement,\n\n  // Types\n  ElementType,\n  ReactElement,\n} from 'react'\nimport { Props, XOR, __, Expand } from '../types'\nimport { match } from './match'\n\nexport enum Features {\n  /** No features at all */\n  None = 0,\n\n  /**\n   * When used, this will allow us to use one of the render strategies.\n   *\n   * **The render strategies are:**\n   *    - **Unmount**   _(Will unmount the component.)_\n   *    - **Hidden**    _(Will hide the component using the [hidden] attribute.)_\n   */\n  RenderStrategy = 1,\n\n  /**\n   * When used, this will allow the user of our component to be in control. This can be used when\n   * you want to transition based on some state.\n   */\n  Static = 2,\n}\n\nexport enum RenderStrategy {\n  Unmount,\n  Hidden,\n}\n\ntype PropsForFeature<TPassedInFeatures extends Features, TForFeature extends Features, TProps> = {\n  [P in TPassedInFeatures]: P extends TForFeature ? TProps : __\n}[TPassedInFeatures]\n\nexport type PropsForFeatures<T extends Features> = XOR<\n  PropsForFeature<T, Features.Static, { static?: boolean }>,\n  PropsForFeature<T, Features.RenderStrategy, { unmount?: boolean }>\n>\n\nexport function render<TFeature extends Features, TTag extends ElementType, TSlot>({\n  props,\n  slot,\n  defaultTag,\n  features,\n  visible = true,\n  name,\n}: {\n  props: Expand<Props<TTag, TSlot, any> & PropsForFeatures<TFeature>>\n  slot?: TSlot\n  defaultTag: ElementType\n  features?: TFeature\n  visible?: boolean\n  name: string\n}) {\n  // Visible always render\n  if (visible) return _render(props, slot, defaultTag, name)\n\n  let featureFlags = features ?? Features.None\n\n  if (featureFlags & Features.Static) {\n    let { static: isStatic = false, ...rest } = props as PropsForFeatures<Features.Static>\n\n    // When the `static` prop is passed as `true`, then the user is in control, thus we don't care about anything else\n    if (isStatic) return _render(rest, slot, defaultTag, name)\n  }\n\n  if (featureFlags & Features.RenderStrategy) {\n    let { unmount = true, ...rest } = props as PropsForFeatures<Features.RenderStrategy>\n    let strategy = unmount ? RenderStrategy.Unmount : RenderStrategy.Hidden\n\n    return match(strategy, {\n      [RenderStrategy.Unmount]() {\n        return null\n      },\n      [RenderStrategy.Hidden]() {\n        return _render(\n          { ...rest, ...{ hidden: true, style: { display: 'none' } } },\n          slot,\n          defaultTag,\n          name\n        )\n      },\n    })\n  }\n\n  // No features enabled, just render\n  return _render(props, slot, defaultTag, name)\n}\n\nfunction _render<TTag extends ElementType, TSlot>(\n  props: Props<TTag, TSlot> & { ref?: unknown },\n  slot: TSlot = {} as TSlot,\n  tag: ElementType,\n  name: string\n) {\n  let { as: Component = tag, children, refName = 'ref', ...passThroughProps } = omit(props, [\n    'unmount',\n    'static',\n  ])\n\n  // This allows us to use `<HeadlessUIComponent as={MyComponent} refName=\"innerRef\" />`\n  let refRelatedProps = props.ref !== undefined ? { [refName]: props.ref } : {}\n\n  let resolvedChildren = (typeof children === 'function' ? children(slot) : children) as\n    | ReactElement\n    | ReactElement[]\n\n  // Allow for className to be a function with the slot as the contents\n  if (passThroughProps.className && typeof passThroughProps.className === 'function') {\n    ;(passThroughProps as any).className = passThroughProps.className(slot)\n  }\n\n  if (Component === Fragment) {\n    if (Object.keys(passThroughProps).length > 0) {\n      if (\n        !isValidElement(resolvedChildren) ||\n        (Array.isArray(resolvedChildren) && resolvedChildren.length > 1)\n      ) {\n        throw new Error(\n          [\n            'Passing props on \"Fragment\"!',\n            '',\n            `The current component <${name} /> is rendering a \"Fragment\".`,\n            `However we need to passthrough the following props:`,\n            Object.keys(passThroughProps)\n              .map(line => `  - ${line}`)\n              .join('\\n'),\n            '',\n            'You can apply a few solutions:',\n            [\n              'Add an `as=\"...\"` prop, to ensure that we render an actual element instead of a \"Fragment\".',\n              'Render a single element as the child so that we can forward the props onto that element.',\n            ]\n              .map(line => `  - ${line}`)\n              .join('\\n'),\n          ].join('\\n')\n        )\n      }\n\n      return cloneElement(\n        resolvedChildren,\n        Object.assign(\n          {},\n          // Filter out undefined values so that they don't override the existing values\n          mergeEventFunctions(compact(omit(passThroughProps, ['ref'])), resolvedChildren.props, [\n            'onClick',\n          ]),\n          refRelatedProps\n        )\n      )\n    }\n  }\n\n  return createElement(\n    Component,\n    Object.assign({}, omit(passThroughProps, ['ref']), Component !== Fragment && refRelatedProps),\n    resolvedChildren\n  )\n}\n\n/**\n * We can use this function for the following useCase:\n *\n * <Menu.Item> <button onClick={console.log} /> </Menu.Item>\n *\n * Our `Menu.Item` will have an internal `onClick`, if you passthrough an `onClick` to the actual\n * `Menu.Item` component we will call it correctly. However, when we have an `onClick` on the actual\n * first child, that one should _also_ be called (but before this implementation, it was just\n * overriding the `onClick`). But it is only when we *render* that we have access to the existing\n * props of this component.\n *\n * It's a bit hacky, and not that clean, but it is something internal and we have tests to rely on\n * so that we can refactor this later (if needed).\n */\nfunction mergeEventFunctions(\n  passThroughProps: Record<string, any>,\n  existingProps: Record<string, any>,\n  functionsToMerge: string[]\n) {\n  let clone = Object.assign({}, passThroughProps)\n  for (let func of functionsToMerge) {\n    if (passThroughProps[func] !== undefined && existingProps[func] !== undefined) {\n      Object.assign(clone, {\n        [func](event: { defaultPrevented: boolean }) {\n          // Props we control\n          if (!event.defaultPrevented) passThroughProps[func](event)\n\n          // Existing props on the component\n          if (!event.defaultPrevented) existingProps[func](event)\n        },\n      })\n    }\n  }\n\n  return clone\n}\n\n/**\n * This is a hack, but basically we want to keep the full 'API' of the component, but we do want to\n * wrap it in a forwardRef so that we _can_ passthrough the ref\n */\nexport function forwardRefWithAs<T extends { name: string; displayName?: string }>(\n  component: T\n): T & { displayName: string } {\n  return Object.assign(forwardRef((component as unknown) as any) as any, {\n    displayName: component.displayName ?? component.name,\n  })\n}\n\nfunction compact<T extends Record<any, any>>(object: T) {\n  let clone = Object.assign({}, object)\n  for (let key in clone) {\n    if (clone[key] === undefined) delete clone[key]\n  }\n  return clone\n}\n\nfunction omit<T extends Record<any, any>>(object: T, keysToOmit: string[] = []) {\n  let clone = Object.assign({}, object)\n  for (let key of keysToOmit) {\n    if (key in clone) delete clone[key]\n  }\n  return clone\n}\n","export function match<TValue extends string | number = string, TReturnValue = unknown>(\n  value: TValue,\n  lookup: Record<TValue, TReturnValue | ((...args: any[]) => TReturnValue)>,\n  ...args: any[]\n): TReturnValue {\n  if (value in lookup) {\n    let returnValue = lookup[value]\n    return typeof returnValue === 'function' ? returnValue(...args) : returnValue\n  }\n\n  let error = new Error(\n    `Tried to handle \"${value}\" but there is no handler defined. Only defined handlers are: ${Object.keys(\n      lookup\n    )\n      .map(key => `\"${key}\"`)\n      .join(', ')}.`\n  )\n  if (Error.captureStackTrace) Error.captureStackTrace(error, match)\n  throw error\n}\n","import { useState, useEffect } from 'react'\n\nlet state = { serverHandoffComplete: false }\n\nexport function useServerHandoffComplete() {\n  let [serverHandoffComplete, setServerHandoffComplete] = useState(state.serverHandoffComplete)\n\n  useEffect(() => {\n    if (serverHandoffComplete === true) return\n\n    setServerHandoffComplete(true)\n  }, [serverHandoffComplete])\n\n  useEffect(() => {\n    if (state.serverHandoffComplete === false) state.serverHandoffComplete = true\n  }, [])\n\n  return serverHandoffComplete\n}\n","import { useState } from 'react'\nimport { useIsoMorphicEffect } from './use-iso-morphic-effect'\nimport { useServerHandoffComplete } from './use-server-handoff-complete'\n\n// We used a \"simple\" approach first which worked for SSR and rehydration on the client. However we\n// didn't take care of the Suspense case. To fix this we used the approach the @reach-ui/auto-id\n// uses.\n//\n// Credits: https://github.com/reach/reach-ui/blob/develop/packages/auto-id/src/index.tsx\n\nlet id = 0\nfunction generateId() {\n  return ++id\n}\n\nexport function useId() {\n  let ready = useServerHandoffComplete()\n  let [id, setId] = useState(ready ? generateId : null)\n\n  useIsoMorphicEffect(() => {\n    if (id === null) setId(generateId())\n  }, [id])\n\n  return id != null ? '' + id : undefined\n}\n","import { useRef, useEffect } from 'react'\n\nexport function useIsMounted() {\n  let mounted = useRef(false)\n\n  useEffect(() => {\n    mounted.current = true\n\n    return () => {\n      mounted.current = false\n    }\n  }, [])\n\n  return mounted\n}\n","import React, {\n  createContext,\n  useContext,\n\n  // Types\n  ReactNode,\n  ReactElement,\n} from 'react'\n\nlet Context = createContext<State | null>(null)\nContext.displayName = 'OpenClosedContext'\n\nexport enum State {\n  Open,\n  Closed,\n}\n\nexport function useOpenClosed() {\n  return useContext(Context)\n}\n\ninterface Props {\n  value: State\n  children: ReactNode\n}\n\nexport function OpenClosedProvider({ value, children }: Props): ReactElement {\n  return <Context.Provider value={value}>{children}</Context.Provider>\n}\n","import { once } from '../../../utils/once'\nimport { disposables } from '../../../utils/disposables'\n\nfunction addClasses(node: HTMLElement, ...classes: string[]) {\n  node && classes.length > 0 && node.classList.add(...classes)\n}\n\nfunction removeClasses(node: HTMLElement, ...classes: string[]) {\n  node && classes.length > 0 && node.classList.remove(...classes)\n}\n\nexport enum Reason {\n  Finished = 'finished',\n  Cancelled = 'cancelled',\n}\n\nfunction waitForTransition(node: HTMLElement, done: (reason: Reason) => void) {\n  let d = disposables()\n\n  if (!node) return d.dispose\n\n  // Safari returns a comma separated list of values, so let's sort them and take the highest value.\n  let { transitionDuration, transitionDelay } = getComputedStyle(node)\n\n  let [durationMs, delaysMs] = [transitionDuration, transitionDelay].map(value => {\n    let [resolvedValue = 0] = value\n      .split(',')\n      // Remove falsy we can't work with\n      .filter(Boolean)\n      // Values are returned as `0.3s` or `75ms`\n      .map(v => (v.includes('ms') ? parseFloat(v) : parseFloat(v) * 1000))\n      .sort((a, z) => z - a)\n\n    return resolvedValue\n  })\n\n  // Waiting for the transition to end. We could use the `transitionend` event, however when no\n  // actual transition/duration is defined then the `transitionend` event is not fired.\n  //\n  // TODO: Downside is, when you slow down transitions via devtools this timeout is still using the\n  // full 100% speed instead of the 25% or 10%.\n  if (durationMs !== 0) {\n    d.setTimeout(() => {\n      done(Reason.Finished)\n    }, durationMs + delaysMs)\n  } else {\n    // No transition is happening, so we should cleanup already. Otherwise we have to wait until we\n    // get disposed.\n    done(Reason.Finished)\n  }\n\n  // If we get disposed before the timeout runs we should cleanup anyway\n  d.add(() => done(Reason.Cancelled))\n\n  return d.dispose\n}\n\nexport function transition(\n  node: HTMLElement,\n  base: string[],\n  from: string[],\n  to: string[],\n  entered: string[],\n  done?: (reason: Reason) => void\n) {\n  let d = disposables()\n  let _done = done !== undefined ? once(done) : () => {}\n\n  removeClasses(node, ...entered)\n  addClasses(node, ...base, ...from)\n\n  d.nextFrame(() => {\n    removeClasses(node, ...from)\n    addClasses(node, ...to)\n\n    d.add(\n      waitForTransition(node, reason => {\n        removeClasses(node, ...to, ...base)\n        addClasses(node, ...entered)\n        return _done(reason)\n      })\n    )\n  })\n\n  // Once we get disposed, we should ensure that we cleanup after ourselves. In case of an unmount,\n  // the node itself will be nullified and will be a no-op. In case of a full transition the classes\n  // are already removed which is also a no-op. However if you go from enter -> leave mid-transition\n  // then we have some leftovers that should be cleaned.\n  d.add(() => removeClasses(node, ...base, ...from, ...to, ...entered))\n\n  // When we get disposed early, than we should also call the done method but switch the reason.\n  d.add(() => _done(Reason.Cancelled))\n\n  return d.dispose\n}\n","export function disposables() {\n  let disposables: Function[] = []\n\n  let api = {\n    requestAnimationFrame(...args: Parameters<typeof requestAnimationFrame>) {\n      let raf = requestAnimationFrame(...args)\n      api.add(() => cancelAnimationFrame(raf))\n    },\n\n    nextFrame(...args: Parameters<typeof requestAnimationFrame>) {\n      api.requestAnimationFrame(() => {\n        api.requestAnimationFrame(...args)\n      })\n    },\n\n    setTimeout(...args: Parameters<typeof setTimeout>) {\n      let timer = setTimeout(...args)\n      api.add(() => clearTimeout(timer))\n    },\n\n    add(cb: () => void) {\n      disposables.push(cb)\n    },\n\n    dispose() {\n      for (let dispose of disposables.splice(0)) {\n        dispose()\n      }\n    },\n  }\n\n  return api\n}\n","export function once<T>(cb: (...args: T[]) => void) {\n  let state = { called: false }\n\n  return (...args: T[]) => {\n    if (state.called) return\n    state.called = true\n    return cb(...args)\n  }\n}\n","import React, {\n  Fragment,\n  createContext,\n  useCallback,\n  useContext,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n\n  // Types\n  ElementType,\n  MutableRefObject,\n} from 'react'\nimport { Props } from '../../types'\n\nimport { useId } from '../../hooks/use-id'\nimport { useIsInitialRender } from '../../hooks/use-is-initial-render'\nimport { match } from '../../utils/match'\nimport { useIsMounted } from '../../hooks/use-is-mounted'\nimport { useIsoMorphicEffect } from '../../hooks/use-iso-morphic-effect'\n\nimport { Features, PropsForFeatures, render, RenderStrategy } from '../../utils/render'\nimport { Reason, transition } from './utils/transition'\nimport { OpenClosedProvider, State, useOpenClosed } from '../../internal/open-closed'\nimport { useServerHandoffComplete } from '../../hooks/use-server-handoff-complete'\n\ntype ID = ReturnType<typeof useId>\n\nfunction useSplitClasses(classes: string = '') {\n  return useMemo(() => classes.split(' ').filter(className => className.trim().length > 1), [\n    classes,\n  ])\n}\n\ninterface TransitionContextValues {\n  show: boolean\n  appear: boolean\n  initial: boolean\n}\nlet TransitionContext = createContext<TransitionContextValues | null>(null)\nTransitionContext.displayName = 'TransitionContext'\n\nenum TreeStates {\n  Visible = 'visible',\n  Hidden = 'hidden',\n}\n\nexport interface TransitionClasses {\n  enter?: string\n  enterFrom?: string\n  enterTo?: string\n  entered?: string\n  leave?: string\n  leaveFrom?: string\n  leaveTo?: string\n}\n\nexport interface TransitionEvents {\n  beforeEnter?: () => void\n  afterEnter?: () => void\n  beforeLeave?: () => void\n  afterLeave?: () => void\n}\n\ntype TransitionChildProps<TTag> = Props<TTag, TransitionChildRenderPropArg> &\n  PropsForFeatures<typeof TransitionChildRenderFeatures> &\n  TransitionClasses &\n  TransitionEvents & { appear?: boolean }\n\nfunction useTransitionContext() {\n  let context = useContext(TransitionContext)\n\n  if (context === null) {\n    throw new Error(\n      'A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.'\n    )\n  }\n\n  return context\n}\n\nfunction useParentNesting() {\n  let context = useContext(NestingContext)\n\n  if (context === null) {\n    throw new Error(\n      'A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.'\n    )\n  }\n\n  return context\n}\n\ninterface NestingContextValues {\n  children: MutableRefObject<{ id: ID; state: TreeStates }[]>\n  register: (id: ID) => () => void\n  unregister: (id: ID, strategy?: RenderStrategy) => void\n}\n\nlet NestingContext = createContext<NestingContextValues | null>(null)\nNestingContext.displayName = 'NestingContext'\n\nfunction hasChildren(\n  bag: NestingContextValues['children'] | { children: NestingContextValues['children'] }\n): boolean {\n  if ('children' in bag) return hasChildren(bag.children)\n  return bag.current.filter(({ state }) => state === TreeStates.Visible).length > 0\n}\n\nfunction useNesting(done?: () => void) {\n  let doneRef = useRef(done)\n  let transitionableChildren = useRef<NestingContextValues['children']['current']>([])\n  let mounted = useIsMounted()\n\n  useEffect(() => {\n    doneRef.current = done\n  }, [done])\n\n  let unregister = useCallback(\n    (childId: ID, strategy = RenderStrategy.Hidden) => {\n      let idx = transitionableChildren.current.findIndex(({ id }) => id === childId)\n      if (idx === -1) return\n\n      match(strategy, {\n        [RenderStrategy.Unmount]() {\n          transitionableChildren.current.splice(idx, 1)\n        },\n        [RenderStrategy.Hidden]() {\n          transitionableChildren.current[idx].state = TreeStates.Hidden\n        },\n      })\n\n      if (!hasChildren(transitionableChildren) && mounted.current) {\n        doneRef.current?.()\n      }\n    },\n    [doneRef, mounted, transitionableChildren]\n  )\n\n  let register = useCallback(\n    (childId: ID) => {\n      let child = transitionableChildren.current.find(({ id }) => id === childId)\n      if (!child) {\n        transitionableChildren.current.push({ id: childId, state: TreeStates.Visible })\n      } else if (child.state !== TreeStates.Visible) {\n        child.state = TreeStates.Visible\n      }\n\n      return () => unregister(childId, RenderStrategy.Unmount)\n    },\n    [transitionableChildren, unregister]\n  )\n\n  return useMemo(\n    () => ({\n      children: transitionableChildren,\n      register,\n      unregister,\n    }),\n    [register, unregister, transitionableChildren]\n  )\n}\n\nfunction noop() {}\nlet eventNames = ['beforeEnter', 'afterEnter', 'beforeLeave', 'afterLeave'] as const\nfunction ensureEventHooksExist(events: TransitionEvents) {\n  let result = {} as Record<keyof typeof events, () => void>\n  for (let name of eventNames) {\n    result[name] = events[name] ?? noop\n  }\n  return result\n}\n\nfunction useEvents(events: TransitionEvents) {\n  let eventsRef = useRef(ensureEventHooksExist(events))\n\n  useEffect(() => {\n    eventsRef.current = ensureEventHooksExist(events)\n  }, [events])\n\n  return eventsRef\n}\n\n// ---\n\nlet DEFAULT_TRANSITION_CHILD_TAG = 'div' as const\ntype TransitionChildRenderPropArg = MutableRefObject<HTMLDivElement>\nlet TransitionChildRenderFeatures = Features.RenderStrategy\n\nfunction TransitionChild<TTag extends ElementType = typeof DEFAULT_TRANSITION_CHILD_TAG>(\n  props: TransitionChildProps<TTag>\n) {\n  let {\n    // Event \"handlers\"\n    beforeEnter,\n    afterEnter,\n    beforeLeave,\n    afterLeave,\n\n    // Class names\n    enter,\n    enterFrom,\n    enterTo,\n    entered,\n    leave,\n    leaveFrom,\n    leaveTo,\n\n    // @ts-expect-error\n    ...rest\n  } = props as typeof props\n  let container = useRef<HTMLElement | null>(null)\n  let [state, setState] = useState(TreeStates.Visible)\n  let strategy = rest.unmount ? RenderStrategy.Unmount : RenderStrategy.Hidden\n\n  let { show, appear, initial } = useTransitionContext()\n  let { register, unregister } = useParentNesting()\n\n  let id = useId()\n\n  let isTransitioning = useRef(false)\n\n  let nesting = useNesting(() => {\n    // When all children have been unmounted we can only hide ourselves if and only if we are not\n    // transitioning ourselves. Otherwise we would unmount before the transitions are finished.\n    if (!isTransitioning.current) {\n      setState(TreeStates.Hidden)\n      unregister(id)\n      events.current.afterLeave()\n    }\n  })\n\n  useIsoMorphicEffect(() => {\n    if (!id) return\n    return register(id)\n  }, [register, id])\n\n  useIsoMorphicEffect(() => {\n    // If we are in another mode than the Hidden mode then ignore\n    if (strategy !== RenderStrategy.Hidden) return\n    if (!id) return\n\n    // Make sure that we are visible\n    if (show && state !== TreeStates.Visible) {\n      setState(TreeStates.Visible)\n      return\n    }\n\n    match(state, {\n      [TreeStates.Hidden]: () => unregister(id),\n      [TreeStates.Visible]: () => register(id),\n    })\n  }, [state, id, register, unregister, show, strategy])\n\n  let enterClasses = useSplitClasses(enter)\n  let enterFromClasses = useSplitClasses(enterFrom)\n  let enterToClasses = useSplitClasses(enterTo)\n\n  let enteredClasses = useSplitClasses(entered)\n\n  let leaveClasses = useSplitClasses(leave)\n  let leaveFromClasses = useSplitClasses(leaveFrom)\n  let leaveToClasses = useSplitClasses(leaveTo)\n\n  let events = useEvents({ beforeEnter, afterEnter, beforeLeave, afterLeave })\n\n  let ready = useServerHandoffComplete()\n\n  useEffect(() => {\n    if (ready && state === TreeStates.Visible && container.current === null) {\n      throw new Error('Did you forget to passthrough the `ref` to the actual DOM node?')\n    }\n  }, [container, state, ready])\n\n  // Skipping initial transition\n  let skip = initial && !appear\n\n  useIsoMorphicEffect(() => {\n    let node = container.current\n    if (!node) return\n    if (skip) return\n\n    isTransitioning.current = true\n\n    if (show) events.current.beforeEnter()\n    if (!show) events.current.beforeLeave()\n\n    return show\n      ? transition(node, enterClasses, enterFromClasses, enterToClasses, enteredClasses, reason => {\n          isTransitioning.current = false\n          if (reason === Reason.Finished) events.current.afterEnter()\n        })\n      : transition(node, leaveClasses, leaveFromClasses, leaveToClasses, enteredClasses, reason => {\n          isTransitioning.current = false\n\n          if (reason !== Reason.Finished) return\n\n          // When we don't have children anymore we can safely unregister from the parent and hide\n          // ourselves.\n          if (!hasChildren(nesting)) {\n            setState(TreeStates.Hidden)\n            unregister(id)\n            events.current.afterLeave()\n          }\n        })\n  }, [\n    events,\n    id,\n    isTransitioning,\n    unregister,\n    nesting,\n    container,\n    skip,\n    show,\n    enterClasses,\n    enterFromClasses,\n    enterToClasses,\n    leaveClasses,\n    leaveFromClasses,\n    leaveToClasses,\n  ])\n\n  let propsWeControl = { ref: container }\n  let passthroughProps = rest\n\n  return (\n    <NestingContext.Provider value={nesting}>\n      <OpenClosedProvider\n        value={match(state, {\n          [TreeStates.Visible]: State.Open,\n          [TreeStates.Hidden]: State.Closed,\n        })}\n      >\n        {render({\n          props: { ...passthroughProps, ...propsWeControl },\n          defaultTag: DEFAULT_TRANSITION_CHILD_TAG,\n          features: TransitionChildRenderFeatures,\n          visible: state === TreeStates.Visible,\n          name: 'Transition.Child',\n        })}\n      </OpenClosedProvider>\n    </NestingContext.Provider>\n  )\n}\n\nexport function Transition<TTag extends ElementType = typeof DEFAULT_TRANSITION_CHILD_TAG>(\n  props: TransitionChildProps<TTag> & { show?: boolean; appear?: boolean }\n) {\n  // @ts-expect-error\n  let { show, appear = false, unmount, ...passthroughProps } = props as typeof props\n\n  let usesOpenClosedState = useOpenClosed()\n\n  if (show === undefined && usesOpenClosedState !== null) {\n    show = match(usesOpenClosedState, {\n      [State.Open]: true,\n      [State.Closed]: false,\n    })\n  }\n\n  if (![true, false].includes((show as unknown) as boolean)) {\n    throw new Error('A <Transition /> is used but it is missing a `show={true | false}` prop.')\n  }\n\n  let [state, setState] = useState(show ? TreeStates.Visible : TreeStates.Hidden)\n\n  let nestingBag = useNesting(() => {\n    setState(TreeStates.Hidden)\n  })\n\n  let initial = useIsInitialRender()\n  let transitionBag = useMemo<TransitionContextValues>(\n    () => ({ show: show as boolean, appear: appear || !initial, initial }),\n    [show, appear, initial]\n  )\n\n  useEffect(() => {\n    if (show) {\n      setState(TreeStates.Visible)\n    } else if (!hasChildren(nestingBag)) {\n      setState(TreeStates.Hidden)\n    }\n  }, [show, nestingBag])\n\n  let sharedProps = { unmount }\n\n  return (\n    <NestingContext.Provider value={nestingBag}>\n      <TransitionContext.Provider value={transitionBag}>\n        {render({\n          props: {\n            ...sharedProps,\n            as: Fragment,\n            children: <TransitionChild {...sharedProps} {...passthroughProps} />,\n          },\n          defaultTag: Fragment,\n          features: TransitionChildRenderFeatures,\n          visible: state === TreeStates.Visible,\n          name: 'Transition',\n        })}\n      </TransitionContext.Provider>\n    </NestingContext.Provider>\n  )\n}\n\nTransition.Child = function Child<TTag extends ElementType = typeof DEFAULT_TRANSITION_CHILD_TAG>(\n  props: TransitionChildProps<TTag>\n) {\n  let hasTransitionContext = useContext(TransitionContext) !== null\n  let hasOpenClosedContext = useOpenClosed() !== null\n\n  return !hasTransitionContext && hasOpenClosedContext ? (\n    <Transition {...props} />\n  ) : (\n    <TransitionChild {...props} />\n  )\n}\nTransition.Root = Transition\n","import { useRef, useEffect } from 'react'\n\nexport function useIsInitialRender() {\n  let initial = useRef(true)\n\n  useEffect(() => {\n    initial.current = false\n  }, [])\n\n  return initial.current\n}\n"],"sourceRoot":""}