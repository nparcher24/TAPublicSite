{"version":3,"sources":["../../../src/hooks/use-iso-morphic-effect.ts","../../../src/utils/render.ts","../../../src/utils/match.ts","../../../src/hooks/use-server-handoff-complete.ts","../../../src/hooks/use-id.ts","../../../src/hooks/use-is-mounted.ts","../../../src/internal/open-closed.tsx","../../../../../src/components/transitions/utils/transition.ts","../../../src/utils/disposables.ts","../../../src/utils/once.ts","../../../../src/components/transitions/transition.tsx","../../../src/hooks/use-is-initial-render.ts"],"names":["useIsoMorphicEffect","window","useEffect","Features","RenderStrategy","render","props","slot","defaultTag","features","visible","name","_render","featureFlags","isStatic","rest","unmount","strategy","match","hidden","style","display","omit","as","Component","tag","children","refName","passThroughProps","refRelatedProps","resolvedChildren","Object","isValidElement","Array","Error","line","cloneElement","clone","func","existingProps","event","mergeEventFunctions","compact","createElement","forwardRefWithAs","component","forwardRef","displayName","keysToOmit","key","value","lookup","returnValue","args","error","state","serverHandoffComplete","useServerHandoffComplete","useState","setServerHandoffComplete","id","generateId","useId","ready","setId","useIsMounted","mounted","useRef","State","Context","createContext","useOpenClosed","useContext","OpenClosedProvider","Reason","disposables","api","requestAnimationFrame","raf","cancelAnimationFrame","nextFrame","setTimeout","timer","clearTimeout","add","dispose","addClasses","node","classes","removeClasses","transition","base","from","to","entered","done","d","_done","cb","called","once","getComputedStyle","transitionDuration","transitionDelay","map","v","parseFloat","z","resolvedValue","durationMs","delaysMs","waitForTransition","reason","useSplitClasses","useMemo","className","TransitionContext","TreeStates","NestingContext","hasChildren","bag","useNesting","doneRef","transitionableChildren","unregister","useCallback","Hidden","idx","register","child","Visible","childId","noop","eventNames","ensureEventHooksExist","events","result","TransitionChildRenderFeatures","TransitionChild","beforeEnter","afterEnter","beforeLeave","afterLeave","enter","enterFrom","enterTo","leave","leaveFrom","leaveTo","container","setState","context","useTransitionContext","show","appear","initial","useParentNesting","isTransitioning","nesting","enterClasses","enterFromClasses","enterToClasses","enteredClasses","leaveClasses","leaveFromClasses","leaveToClasses","eventsRef","useEvents","skip","propsWeControl","ref","passthroughProps","Transition","usesOpenClosedState","includes","nestingBag","useIsInitialRender","transitionBag","sharedProps","React","hasTransitionContext","hasOpenClosedContext"],"mappings":"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","file":"static/js/0.29179d2a.chunk.js","sourcesContent":["import { useLayoutEffect, useEffect } from 'react'\n\nexport const useIsoMorphicEffect = typeof window !== 'undefined' ? useLayoutEffect : useEffect\n","import {\n  Fragment,\n  cloneElement,\n  createElement,\n  forwardRef,\n  isValidElement,\n\n  // Types\n  ElementType,\n  ReactElement,\n} from 'react'\nimport { Props, XOR, __, Expand } from '../types'\nimport { match } from './match'\n\nexport enum Features {\n  /** No features at all */\n  None = 0,\n\n  /**\n   * When used, this will allow us to use one of the render strategies.\n   *\n   * **The render strategies are:**\n   *    - **Unmount**   _(Will unmount the component.)_\n   *    - **Hidden**    _(Will hide the component using the [hidden] attribute.)_\n   */\n  RenderStrategy = 1,\n\n  /**\n   * When used, this will allow the user of our component to be in control. This can be used when\n   * you want to transition based on some state.\n   */\n  Static = 2,\n}\n\nexport enum RenderStrategy {\n  Unmount,\n  Hidden,\n}\n\ntype PropsForFeature<TPassedInFeatures extends Features, TForFeature extends Features, TProps> = {\n  [P in TPassedInFeatures]: P extends TForFeature ? TProps : __\n}[TPassedInFeatures]\n\nexport type PropsForFeatures<T extends Features> = XOR<\n  PropsForFeature<T, Features.Static, { static?: boolean }>,\n  PropsForFeature<T, Features.RenderStrategy, { unmount?: boolean }>\n>\n\nexport function render<TFeature extends Features, TTag extends ElementType, TSlot>({\n  props,\n  slot,\n  defaultTag,\n  features,\n  visible = true,\n  name,\n}: {\n  props: Expand<Props<TTag, TSlot, any> & PropsForFeatures<TFeature>>\n  slot?: TSlot\n  defaultTag: ElementType\n  features?: TFeature\n  visible?: boolean\n  name: string\n}) {\n  // Visible always render\n  if (visible) return _render(props, slot, defaultTag, name)\n\n  let featureFlags = features ?? Features.None\n\n  if (featureFlags & Features.Static) {\n    let { static: isStatic = false, ...rest } = props as PropsForFeatures<Features.Static>\n\n    // When the `static` prop is passed as `true`, then the user is in control, thus we don't care about anything else\n    if (isStatic) return _render(rest, slot, defaultTag, name)\n  }\n\n  if (featureFlags & Features.RenderStrategy) {\n    let { unmount = true, ...rest } = props as PropsForFeatures<Features.RenderStrategy>\n    let strategy = unmount ? RenderStrategy.Unmount : RenderStrategy.Hidden\n\n    return match(strategy, {\n      [RenderStrategy.Unmount]() {\n        return null\n      },\n      [RenderStrategy.Hidden]() {\n        return _render(\n          { ...rest, ...{ hidden: true, style: { display: 'none' } } },\n          slot,\n          defaultTag,\n          name\n        )\n      },\n    })\n  }\n\n  // No features enabled, just render\n  return _render(props, slot, defaultTag, name)\n}\n\nfunction _render<TTag extends ElementType, TSlot>(\n  props: Props<TTag, TSlot> & { ref?: unknown },\n  slot: TSlot = {} as TSlot,\n  tag: ElementType,\n  name: string\n) {\n  let { as: Component = tag, children, refName = 'ref', ...passThroughProps } = omit(props, [\n    'unmount',\n    'static',\n  ])\n\n  // This allows us to use `<HeadlessUIComponent as={MyComponent} refName=\"innerRef\" />`\n  let refRelatedProps = props.ref !== undefined ? { [refName]: props.ref } : {}\n\n  let resolvedChildren = (typeof children === 'function' ? children(slot) : children) as\n    | ReactElement\n    | ReactElement[]\n\n  // Allow for className to be a function with the slot as the contents\n  if (passThroughProps.className && typeof passThroughProps.className === 'function') {\n    ;(passThroughProps as any).className = passThroughProps.className(slot)\n  }\n\n  if (Component === Fragment) {\n    if (Object.keys(passThroughProps).length > 0) {\n      if (\n        !isValidElement(resolvedChildren) ||\n        (Array.isArray(resolvedChildren) && resolvedChildren.length > 1)\n      ) {\n        throw new Error(\n          [\n            'Passing props on \"Fragment\"!',\n            '',\n            `The current component <${name} /> is rendering a \"Fragment\".`,\n            `However we need to passthrough the following props:`,\n            Object.keys(passThroughProps)\n              .map(line => `  - ${line}`)\n              .join('\\n'),\n            '',\n            'You can apply a few solutions:',\n            [\n              'Add an `as=\"...\"` prop, to ensure that we render an actual element instead of a \"Fragment\".',\n              'Render a single element as the child so that we can forward the props onto that element.',\n            ]\n              .map(line => `  - ${line}`)\n              .join('\\n'),\n          ].join('\\n')\n        )\n      }\n\n      return cloneElement(\n        resolvedChildren,\n        Object.assign(\n          {},\n          // Filter out undefined values so that they don't override the existing values\n          mergeEventFunctions(compact(omit(passThroughProps, ['ref'])), resolvedChildren.props, [\n            'onClick',\n          ]),\n          refRelatedProps\n        )\n      )\n    }\n  }\n\n  return createElement(\n    Component,\n    Object.assign({}, omit(passThroughProps, ['ref']), Component !== Fragment && refRelatedProps),\n    resolvedChildren\n  )\n}\n\n/**\n * We can use this function for the following useCase:\n *\n * <Menu.Item> <button onClick={console.log} /> </Menu.Item>\n *\n * Our `Menu.Item` will have an internal `onClick`, if you passthrough an `onClick` to the actual\n * `Menu.Item` component we will call it correctly. However, when we have an `onClick` on the actual\n * first child, that one should _also_ be called (but before this implementation, it was just\n * overriding the `onClick`). But it is only when we *render* that we have access to the existing\n * props of this component.\n *\n * It's a bit hacky, and not that clean, but it is something internal and we have tests to rely on\n * so that we can refactor this later (if needed).\n */\nfunction mergeEventFunctions(\n  passThroughProps: Record<string, any>,\n  existingProps: Record<string, any>,\n  functionsToMerge: string[]\n) {\n  let clone = Object.assign({}, passThroughProps)\n  for (let func of functionsToMerge) {\n    if (passThroughProps[func] !== undefined && existingProps[func] !== undefined) {\n      Object.assign(clone, {\n        [func](event: { defaultPrevented: boolean }) {\n          // Props we control\n          if (!event.defaultPrevented) passThroughProps[func](event)\n\n          // Existing props on the component\n          if (!event.defaultPrevented) existingProps[func](event)\n        },\n      })\n    }\n  }\n\n  return clone\n}\n\n/**\n * This is a hack, but basically we want to keep the full 'API' of the component, but we do want to\n * wrap it in a forwardRef so that we _can_ passthrough the ref\n */\nexport function forwardRefWithAs<T extends { name: string; displayName?: string }>(\n  component: T\n): T & { displayName: string } {\n  return Object.assign(forwardRef((component as unknown) as any) as any, {\n    displayName: component.displayName ?? component.name,\n  })\n}\n\nfunction compact<T extends Record<any, any>>(object: T) {\n  let clone = Object.assign({}, object)\n  for (let key in clone) {\n    if (clone[key] === undefined) delete clone[key]\n  }\n  return clone\n}\n\nfunction omit<T extends Record<any, any>>(object: T, keysToOmit: string[] = []) {\n  let clone = Object.assign({}, object)\n  for (let key of keysToOmit) {\n    if (key in clone) delete clone[key]\n  }\n  return clone\n}\n","export function match<TValue extends string | number = string, TReturnValue = unknown>(\n  value: TValue,\n  lookup: Record<TValue, TReturnValue | ((...args: any[]) => TReturnValue)>,\n  ...args: any[]\n): TReturnValue {\n  if (value in lookup) {\n    let returnValue = lookup[value]\n    return typeof returnValue === 'function' ? returnValue(...args) : returnValue\n  }\n\n  let error = new Error(\n    `Tried to handle \"${value}\" but there is no handler defined. Only defined handlers are: ${Object.keys(\n      lookup\n    )\n      .map(key => `\"${key}\"`)\n      .join(', ')}.`\n  )\n  if (Error.captureStackTrace) Error.captureStackTrace(error, match)\n  throw error\n}\n","import { useState, useEffect } from 'react'\n\nlet state = { serverHandoffComplete: false }\n\nexport function useServerHandoffComplete() {\n  let [serverHandoffComplete, setServerHandoffComplete] = useState(state.serverHandoffComplete)\n\n  useEffect(() => {\n    if (serverHandoffComplete === true) return\n\n    setServerHandoffComplete(true)\n  }, [serverHandoffComplete])\n\n  useEffect(() => {\n    if (state.serverHandoffComplete === false) state.serverHandoffComplete = true\n  }, [])\n\n  return serverHandoffComplete\n}\n","import { useState } from 'react'\nimport { useIsoMorphicEffect } from './use-iso-morphic-effect'\nimport { useServerHandoffComplete } from './use-server-handoff-complete'\n\n// We used a \"simple\" approach first which worked for SSR and rehydration on the client. However we\n// didn't take care of the Suspense case. To fix this we used the approach the @reach-ui/auto-id\n// uses.\n//\n// Credits: https://github.com/reach/reach-ui/blob/develop/packages/auto-id/src/index.tsx\n\nlet id = 0\nfunction generateId() {\n  return ++id\n}\n\nexport function useId() {\n  let ready = useServerHandoffComplete()\n  let [id, setId] = useState(ready ? generateId : null)\n\n  useIsoMorphicEffect(() => {\n    if (id === null) setId(generateId())\n  }, [id])\n\n  return id != null ? '' + id : undefined\n}\n","import { useRef, useEffect } from 'react'\n\nexport function useIsMounted() {\n  let mounted = useRef(false)\n\n  useEffect(() => {\n    mounted.current = true\n\n    return () => {\n      mounted.current = false\n    }\n  }, [])\n\n  return mounted\n}\n","import React, {\n  createContext,\n  useContext,\n\n  // Types\n  ReactNode,\n  ReactElement,\n} from 'react'\n\nlet Context = createContext<State | null>(null)\nContext.displayName = 'OpenClosedContext'\n\nexport enum State {\n  Open,\n  Closed,\n}\n\nexport function useOpenClosed() {\n  return useContext(Context)\n}\n\ninterface Props {\n  value: State\n  children: ReactNode\n}\n\nexport function OpenClosedProvider({ value, children }: Props): ReactElement {\n  return <Context.Provider value={value}>{children}</Context.Provider>\n}\n","import { once } from '../../../utils/once'\nimport { disposables } from '../../../utils/disposables'\n\nfunction addClasses(node: HTMLElement, ...classes: string[]) {\n  node && classes.length > 0 && node.classList.add(...classes)\n}\n\nfunction removeClasses(node: HTMLElement, ...classes: string[]) {\n  node && classes.length > 0 && node.classList.remove(...classes)\n}\n\nexport enum Reason {\n  Finished = 'finished',\n  Cancelled = 'cancelled',\n}\n\nfunction waitForTransition(node: HTMLElement, done: (reason: Reason) => void) {\n  let d = disposables()\n\n  if (!node) return d.dispose\n\n  // Safari returns a comma separated list of values, so let's sort them and take the highest value.\n  let { transitionDuration, transitionDelay } = getComputedStyle(node)\n\n  let [durationMs, delaysMs] = [transitionDuration, transitionDelay].map(value => {\n    let [resolvedValue = 0] = value\n      .split(',')\n      // Remove falsy we can't work with\n      .filter(Boolean)\n      // Values are returned as `0.3s` or `75ms`\n      .map(v => (v.includes('ms') ? parseFloat(v) : parseFloat(v) * 1000))\n      .sort((a, z) => z - a)\n\n    return resolvedValue\n  })\n\n  // Waiting for the transition to end. We could use the `transitionend` event, however when no\n  // actual transition/duration is defined then the `transitionend` event is not fired.\n  //\n  // TODO: Downside is, when you slow down transitions via devtools this timeout is still using the\n  // full 100% speed instead of the 25% or 10%.\n  if (durationMs !== 0) {\n    d.setTimeout(() => {\n      done(Reason.Finished)\n    }, durationMs + delaysMs)\n  } else {\n    // No transition is happening, so we should cleanup already. Otherwise we have to wait until we\n    // get disposed.\n    done(Reason.Finished)\n  }\n\n  // If we get disposed before the timeout runs we should cleanup anyway\n  d.add(() => done(Reason.Cancelled))\n\n  return d.dispose\n}\n\nexport function transition(\n  node: HTMLElement,\n  base: string[],\n  from: string[],\n  to: string[],\n  entered: string[],\n  done?: (reason: Reason) => void\n) {\n  let d = disposables()\n  let _done = done !== undefined ? once(done) : () => {}\n\n  removeClasses(node, ...entered)\n  addClasses(node, ...base, ...from)\n\n  d.nextFrame(() => {\n    removeClasses(node, ...from)\n    addClasses(node, ...to)\n\n    d.add(\n      waitForTransition(node, reason => {\n        removeClasses(node, ...to, ...base)\n        addClasses(node, ...entered)\n        return _done(reason)\n      })\n    )\n  })\n\n  // Once we get disposed, we should ensure that we cleanup after ourselves. In case of an unmount,\n  // the node itself will be nullified and will be a no-op. In case of a full transition the classes\n  // are already removed which is also a no-op. However if you go from enter -> leave mid-transition\n  // then we have some leftovers that should be cleaned.\n  d.add(() => removeClasses(node, ...base, ...from, ...to, ...entered))\n\n  // When we get disposed early, than we should also call the done method but switch the reason.\n  d.add(() => _done(Reason.Cancelled))\n\n  return d.dispose\n}\n","export function disposables() {\n  let disposables: Function[] = []\n\n  let api = {\n    requestAnimationFrame(...args: Parameters<typeof requestAnimationFrame>) {\n      let raf = requestAnimationFrame(...args)\n      api.add(() => cancelAnimationFrame(raf))\n    },\n\n    nextFrame(...args: Parameters<typeof requestAnimationFrame>) {\n      api.requestAnimationFrame(() => {\n        api.requestAnimationFrame(...args)\n      })\n    },\n\n    setTimeout(...args: Parameters<typeof setTimeout>) {\n      let timer = setTimeout(...args)\n      api.add(() => clearTimeout(timer))\n    },\n\n    add(cb: () => void) {\n      disposables.push(cb)\n    },\n\n    dispose() {\n      for (let dispose of disposables.splice(0)) {\n        dispose()\n      }\n    },\n  }\n\n  return api\n}\n","export function once<T>(cb: (...args: T[]) => void) {\n  let state = { called: false }\n\n  return (...args: T[]) => {\n    if (state.called) return\n    state.called = true\n    return cb(...args)\n  }\n}\n","import React, {\n  Fragment,\n  createContext,\n  useCallback,\n  useContext,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n\n  // Types\n  ElementType,\n  MutableRefObject,\n} from 'react'\nimport { Props } from '../../types'\n\nimport { useId } from '../../hooks/use-id'\nimport { useIsInitialRender } from '../../hooks/use-is-initial-render'\nimport { match } from '../../utils/match'\nimport { useIsMounted } from '../../hooks/use-is-mounted'\nimport { useIsoMorphicEffect } from '../../hooks/use-iso-morphic-effect'\n\nimport { Features, PropsForFeatures, render, RenderStrategy } from '../../utils/render'\nimport { Reason, transition } from './utils/transition'\nimport { OpenClosedProvider, State, useOpenClosed } from '../../internal/open-closed'\nimport { useServerHandoffComplete } from '../../hooks/use-server-handoff-complete'\n\ntype ID = ReturnType<typeof useId>\n\nfunction useSplitClasses(classes: string = '') {\n  return useMemo(() => classes.split(' ').filter(className => className.trim().length > 1), [\n    classes,\n  ])\n}\n\ninterface TransitionContextValues {\n  show: boolean\n  appear: boolean\n  initial: boolean\n}\nlet TransitionContext = createContext<TransitionContextValues | null>(null)\nTransitionContext.displayName = 'TransitionContext'\n\nenum TreeStates {\n  Visible = 'visible',\n  Hidden = 'hidden',\n}\n\nexport interface TransitionClasses {\n  enter?: string\n  enterFrom?: string\n  enterTo?: string\n  entered?: string\n  leave?: string\n  leaveFrom?: string\n  leaveTo?: string\n}\n\nexport interface TransitionEvents {\n  beforeEnter?: () => void\n  afterEnter?: () => void\n  beforeLeave?: () => void\n  afterLeave?: () => void\n}\n\ntype TransitionChildProps<TTag> = Props<TTag, TransitionChildRenderPropArg> &\n  PropsForFeatures<typeof TransitionChildRenderFeatures> &\n  TransitionClasses &\n  TransitionEvents & { appear?: boolean }\n\nfunction useTransitionContext() {\n  let context = useContext(TransitionContext)\n\n  if (context === null) {\n    throw new Error(\n      'A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.'\n    )\n  }\n\n  return context\n}\n\nfunction useParentNesting() {\n  let context = useContext(NestingContext)\n\n  if (context === null) {\n    throw new Error(\n      'A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.'\n    )\n  }\n\n  return context\n}\n\ninterface NestingContextValues {\n  children: MutableRefObject<{ id: ID; state: TreeStates }[]>\n  register: (id: ID) => () => void\n  unregister: (id: ID, strategy?: RenderStrategy) => void\n}\n\nlet NestingContext = createContext<NestingContextValues | null>(null)\nNestingContext.displayName = 'NestingContext'\n\nfunction hasChildren(\n  bag: NestingContextValues['children'] | { children: NestingContextValues['children'] }\n): boolean {\n  if ('children' in bag) return hasChildren(bag.children)\n  return bag.current.filter(({ state }) => state === TreeStates.Visible).length > 0\n}\n\nfunction useNesting(done?: () => void) {\n  let doneRef = useRef(done)\n  let transitionableChildren = useRef<NestingContextValues['children']['current']>([])\n  let mounted = useIsMounted()\n\n  useEffect(() => {\n    doneRef.current = done\n  }, [done])\n\n  let unregister = useCallback(\n    (childId: ID, strategy = RenderStrategy.Hidden) => {\n      let idx = transitionableChildren.current.findIndex(({ id }) => id === childId)\n      if (idx === -1) return\n\n      match(strategy, {\n        [RenderStrategy.Unmount]() {\n          transitionableChildren.current.splice(idx, 1)\n        },\n        [RenderStrategy.Hidden]() {\n          transitionableChildren.current[idx].state = TreeStates.Hidden\n        },\n      })\n\n      if (!hasChildren(transitionableChildren) && mounted.current) {\n        doneRef.current?.()\n      }\n    },\n    [doneRef, mounted, transitionableChildren]\n  )\n\n  let register = useCallback(\n    (childId: ID) => {\n      let child = transitionableChildren.current.find(({ id }) => id === childId)\n      if (!child) {\n        transitionableChildren.current.push({ id: childId, state: TreeStates.Visible })\n      } else if (child.state !== TreeStates.Visible) {\n        child.state = TreeStates.Visible\n      }\n\n      return () => unregister(childId, RenderStrategy.Unmount)\n    },\n    [transitionableChildren, unregister]\n  )\n\n  return useMemo(\n    () => ({\n      children: transitionableChildren,\n      register,\n      unregister,\n    }),\n    [register, unregister, transitionableChildren]\n  )\n}\n\nfunction noop() {}\nlet eventNames = ['beforeEnter', 'afterEnter', 'beforeLeave', 'afterLeave'] as const\nfunction ensureEventHooksExist(events: TransitionEvents) {\n  let result = {} as Record<keyof typeof events, () => void>\n  for (let name of eventNames) {\n    result[name] = events[name] ?? noop\n  }\n  return result\n}\n\nfunction useEvents(events: TransitionEvents) {\n  let eventsRef = useRef(ensureEventHooksExist(events))\n\n  useEffect(() => {\n    eventsRef.current = ensureEventHooksExist(events)\n  }, [events])\n\n  return eventsRef\n}\n\n// ---\n\nlet DEFAULT_TRANSITION_CHILD_TAG = 'div' as const\ntype TransitionChildRenderPropArg = MutableRefObject<HTMLDivElement>\nlet TransitionChildRenderFeatures = Features.RenderStrategy\n\nfunction TransitionChild<TTag extends ElementType = typeof DEFAULT_TRANSITION_CHILD_TAG>(\n  props: TransitionChildProps<TTag>\n) {\n  let {\n    // Event \"handlers\"\n    beforeEnter,\n    afterEnter,\n    beforeLeave,\n    afterLeave,\n\n    // Class names\n    enter,\n    enterFrom,\n    enterTo,\n    entered,\n    leave,\n    leaveFrom,\n    leaveTo,\n\n    // @ts-expect-error\n    ...rest\n  } = props as typeof props\n  let container = useRef<HTMLElement | null>(null)\n  let [state, setState] = useState(TreeStates.Visible)\n  let strategy = rest.unmount ? RenderStrategy.Unmount : RenderStrategy.Hidden\n\n  let { show, appear, initial } = useTransitionContext()\n  let { register, unregister } = useParentNesting()\n\n  let id = useId()\n\n  let isTransitioning = useRef(false)\n\n  let nesting = useNesting(() => {\n    // When all children have been unmounted we can only hide ourselves if and only if we are not\n    // transitioning ourselves. Otherwise we would unmount before the transitions are finished.\n    if (!isTransitioning.current) {\n      setState(TreeStates.Hidden)\n      unregister(id)\n      events.current.afterLeave()\n    }\n  })\n\n  useIsoMorphicEffect(() => {\n    if (!id) return\n    return register(id)\n  }, [register, id])\n\n  useIsoMorphicEffect(() => {\n    // If we are in another mode than the Hidden mode then ignore\n    if (strategy !== RenderStrategy.Hidden) return\n    if (!id) return\n\n    // Make sure that we are visible\n    if (show && state !== TreeStates.Visible) {\n      setState(TreeStates.Visible)\n      return\n    }\n\n    match(state, {\n      [TreeStates.Hidden]: () => unregister(id),\n      [TreeStates.Visible]: () => register(id),\n    })\n  }, [state, id, register, unregister, show, strategy])\n\n  let enterClasses = useSplitClasses(enter)\n  let enterFromClasses = useSplitClasses(enterFrom)\n  let enterToClasses = useSplitClasses(enterTo)\n\n  let enteredClasses = useSplitClasses(entered)\n\n  let leaveClasses = useSplitClasses(leave)\n  let leaveFromClasses = useSplitClasses(leaveFrom)\n  let leaveToClasses = useSplitClasses(leaveTo)\n\n  let events = useEvents({ beforeEnter, afterEnter, beforeLeave, afterLeave })\n\n  let ready = useServerHandoffComplete()\n\n  useEffect(() => {\n    if (ready && state === TreeStates.Visible && container.current === null) {\n      throw new Error('Did you forget to passthrough the `ref` to the actual DOM node?')\n    }\n  }, [container, state, ready])\n\n  // Skipping initial transition\n  let skip = initial && !appear\n\n  useIsoMorphicEffect(() => {\n    let node = container.current\n    if (!node) return\n    if (skip) return\n\n    isTransitioning.current = true\n\n    if (show) events.current.beforeEnter()\n    if (!show) events.current.beforeLeave()\n\n    return show\n      ? transition(node, enterClasses, enterFromClasses, enterToClasses, enteredClasses, reason => {\n          isTransitioning.current = false\n          if (reason === Reason.Finished) events.current.afterEnter()\n        })\n      : transition(node, leaveClasses, leaveFromClasses, leaveToClasses, enteredClasses, reason => {\n          isTransitioning.current = false\n\n          if (reason !== Reason.Finished) return\n\n          // When we don't have children anymore we can safely unregister from the parent and hide\n          // ourselves.\n          if (!hasChildren(nesting)) {\n            setState(TreeStates.Hidden)\n            unregister(id)\n            events.current.afterLeave()\n          }\n        })\n  }, [\n    events,\n    id,\n    isTransitioning,\n    unregister,\n    nesting,\n    container,\n    skip,\n    show,\n    enterClasses,\n    enterFromClasses,\n    enterToClasses,\n    leaveClasses,\n    leaveFromClasses,\n    leaveToClasses,\n  ])\n\n  let propsWeControl = { ref: container }\n  let passthroughProps = rest\n\n  return (\n    <NestingContext.Provider value={nesting}>\n      <OpenClosedProvider\n        value={match(state, {\n          [TreeStates.Visible]: State.Open,\n          [TreeStates.Hidden]: State.Closed,\n        })}\n      >\n        {render({\n          props: { ...passthroughProps, ...propsWeControl },\n          defaultTag: DEFAULT_TRANSITION_CHILD_TAG,\n          features: TransitionChildRenderFeatures,\n          visible: state === TreeStates.Visible,\n          name: 'Transition.Child',\n        })}\n      </OpenClosedProvider>\n    </NestingContext.Provider>\n  )\n}\n\nexport function Transition<TTag extends ElementType = typeof DEFAULT_TRANSITION_CHILD_TAG>(\n  props: TransitionChildProps<TTag> & { show?: boolean; appear?: boolean }\n) {\n  // @ts-expect-error\n  let { show, appear = false, unmount, ...passthroughProps } = props as typeof props\n\n  let usesOpenClosedState = useOpenClosed()\n\n  if (show === undefined && usesOpenClosedState !== null) {\n    show = match(usesOpenClosedState, {\n      [State.Open]: true,\n      [State.Closed]: false,\n    })\n  }\n\n  if (![true, false].includes((show as unknown) as boolean)) {\n    throw new Error('A <Transition /> is used but it is missing a `show={true | false}` prop.')\n  }\n\n  let [state, setState] = useState(show ? TreeStates.Visible : TreeStates.Hidden)\n\n  let nestingBag = useNesting(() => {\n    setState(TreeStates.Hidden)\n  })\n\n  let initial = useIsInitialRender()\n  let transitionBag = useMemo<TransitionContextValues>(\n    () => ({ show: show as boolean, appear: appear || !initial, initial }),\n    [show, appear, initial]\n  )\n\n  useEffect(() => {\n    if (show) {\n      setState(TreeStates.Visible)\n    } else if (!hasChildren(nestingBag)) {\n      setState(TreeStates.Hidden)\n    }\n  }, [show, nestingBag])\n\n  let sharedProps = { unmount }\n\n  return (\n    <NestingContext.Provider value={nestingBag}>\n      <TransitionContext.Provider value={transitionBag}>\n        {render({\n          props: {\n            ...sharedProps,\n            as: Fragment,\n            children: <TransitionChild {...sharedProps} {...passthroughProps} />,\n          },\n          defaultTag: Fragment,\n          features: TransitionChildRenderFeatures,\n          visible: state === TreeStates.Visible,\n          name: 'Transition',\n        })}\n      </TransitionContext.Provider>\n    </NestingContext.Provider>\n  )\n}\n\nTransition.Child = function Child<TTag extends ElementType = typeof DEFAULT_TRANSITION_CHILD_TAG>(\n  props: TransitionChildProps<TTag>\n) {\n  let hasTransitionContext = useContext(TransitionContext) !== null\n  let hasOpenClosedContext = useOpenClosed() !== null\n\n  return !hasTransitionContext && hasOpenClosedContext ? (\n    <Transition {...props} />\n  ) : (\n    <TransitionChild {...props} />\n  )\n}\nTransition.Root = Transition\n","import { useRef, useEffect } from 'react'\n\nexport function useIsInitialRender() {\n  let initial = useRef(true)\n\n  useEffect(() => {\n    initial.current = false\n  }, [])\n\n  return initial.current\n}\n"],"sourceRoot":""}